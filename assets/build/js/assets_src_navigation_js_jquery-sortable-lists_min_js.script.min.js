/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunksails_adminpanel"] = self["webpackChunksails_adminpanel"] || []).push([["assets_src_navigation_js_jquery-sortable-lists_min_js"],{

/***/ "./assets/src/navigation/js/jquery-sortable-lists.min.js":
/*!***************************************************************!*\
  !*** ./assets/src/navigation/js/jquery-sortable-lists.min.js ***!
  \***************************************************************/
/***/ (() => {

eval("/**\r\n * @desc jQuery plugin to sort html list also the tree structures\r\n * @author Vladimír Čamaj\r\n * @license MIT\r\n */\r\n\r\n( function( $ )\r\n{\r\n\r\n    /**\r\n     * @desc jQuery plugin\r\n     * @param options\r\n     * @returns this to unsure chaining\r\n     */\r\n    $.fn.sortableLists = function( options )\r\n    {\r\n        // Local variables. This scope is available for all the functions in this closure.\r\n        var jQBody = $( 'body' ).css( 'position', 'relative' ),\r\n\r\n            defaults = {\r\n                currElClass: '',\r\n                placeholderClass: '',\r\n                placeholderCss: {\r\n                    'position': 'relative',\r\n                    'padding': 0\r\n                },\r\n                hintClass: '',\r\n                hintCss: {\r\n                    'display': 'none',\r\n                    'position': 'relative',\r\n                    'padding': 0\r\n                },\r\n                hintWrapperClass: '',\r\n                hintWrapperCss: { /* Description is below the defaults in this var section */ },\r\n                baseClass: '',\r\n                baseCss: {\r\n                    'position': 'absolute',\r\n                    'top': 0 - parseInt( jQBody.css( 'margin-top' ) ),\r\n                    'left': 0 - parseInt( jQBody.css( 'margin-left' ) ),\r\n                    'margin': 0,\r\n                    'padding': 0,\r\n                    'z-index': 2500\r\n                },\r\n                opener: {\r\n                    active: false,\r\n                    open: '',\r\n                    close: '',\r\n                    openerCss: {\r\n                        'float': 'left',\r\n                        'display': 'inline-block',\r\n                        'background-position': 'center center',\r\n                        'background-repeat': 'no-repeat'\r\n                    },\r\n                    openerClass: ''\r\n                },\r\n                maxLevels: false,\r\n                listSelector: 'ul',\r\n                listsClass: '', // Used for hintWrapper and baseElement\r\n                listsCss: {},\r\n                insertZone: 50,\r\n                insertZonePlus: false,\r\n                scroll: 20,\r\n                ignoreClass: '',\r\n                isAllowed: function( cEl, hint, target ) { return true; },  // Params: current el., hint el.\r\n                onDragStart: function( e, cEl ) { return true; },  // Params: e jQ. event obj., current el.\r\n                onChange: function( cEl ) { return true; },  // Params: current el.\r\n                complete: function( cEl ) { return true; }  // Params: current el.\r\n            },\r\n\r\n            setting = $.extend( true, {}, defaults, options ),\r\n\r\n            // base element from which is counted position of draged element\r\n            base = $( '<' + setting.listSelector + ' />' )\r\n                .prependTo( jQBody )\r\n                .attr( 'id', 's-l-base' )\r\n                .css( setting.baseCss )\r\n                .addClass( setting.listsClass + ' ' + setting.baseClass ),\r\n\r\n            // placeholder != state.placeholderNode\r\n            // placeholder is document fragment and state.placeholderNode is document node\r\n            placeholder = $( '<li />' )\r\n                .attr( 'id', 's-l-placeholder' )\r\n                .css( setting.placeholderCss )\r\n                .addClass( setting.placeholderClass ),\r\n\r\n            // hint is document fragment\r\n            hint = $( '<li />' )\r\n                .attr( 'id', 's-l-hint' )\r\n                .css( setting.hintCss )\r\n                .addClass( setting.hintClass ),\r\n\r\n            // Is document fragment used as wrapper if hint is inserted to the empty li\r\n            hintWrapper = $( '<' + setting.listSelector + ' />' )\r\n                .attr( 'id', 's-l-hint-wrapper' )\r\n                .addClass( setting.listsClass + ' ' + setting.hintWrapperClass )\r\n                .css( setting.listsCss )\r\n                .css( setting.hintWrapperCss ),\r\n\r\n            // Is +/- ikon to open/close nested lists\r\n            opener = $( '<span />' )\r\n                .addClass( 's-l-opener ' + setting.opener.openerClass )\r\n                .css( setting.opener.openerCss )\r\n                .on( 'mousedown', function( e )\r\n                {\r\n                    var li = $( this ).closest( 'li' );\r\n\r\n                    if ( li.hasClass( 's-l-closed' ) )\r\n                    {\r\n                        open( li );\r\n                    }\r\n                    else\r\n                    {\r\n                        close( li );\r\n                    }\r\n\r\n                    return false; // Prevent default\r\n                } );\r\n\r\n        if ( setting.opener.as == 'class' )\r\n        {\r\n            opener.addClass( setting.opener.close );\r\n        }\r\n        else if ( setting.opener.as == 'html' )\r\n        {\r\n            opener.html( setting.opener.close );\r\n        }\r\n        else\r\n        {\r\n            console.error( 'jQuerySortableLists opener as background image has been removed with release 2.0.0. Use html instead please.' );\r\n        }\r\n\r\n        // Container with all actual elements and parameters\r\n        var state = {\r\n            isDragged: false,\r\n            isRelEFP: null,  // How browser counts elementFromPoint() position (relative to window/document)\r\n            oEl: null, // overElement is element which returns elementFromPoint() method\r\n            rootEl: {\r\n                el: $( this ),\r\n                offset: null,\r\n                rootElClass: $( this ).attr( 'class' )\r\n            },\r\n            cEl: null, // currentElement is currently dragged element\r\n            placeholderParentLi: null,\r\n            upScroll: false,\r\n            downScroll: false,\r\n            pX: 0,\r\n            pY: 0,\r\n            cX: 0,\r\n            cY: 0,\r\n            isAllowed: true, // The function is defined in setting\r\n            e: { pageX: 0, pageY: 0, clientX: 0, clientY: 0 }, // TODO: unused??\r\n            doc: $( document ),\r\n            win: $( window )\r\n        };\r\n\r\n        if ( setting.opener.active )\r\n        {\r\n            if ( ! setting.opener.open ) throw 'Opener.open value is not defined. It should be valid url, html or css class.';\r\n            if ( ! setting.opener.close ) throw 'Opener.close value is not defined. It should be valid url, html or css class.';\r\n\r\n            $( this ).find( 'li' ).each( function()\r\n            {\r\n                var li = $( this );\r\n\r\n                if ( li.children( setting.listSelector ).length )\r\n                {\r\n                    opener.clone( true ).prependTo( li.children( 'div' ).first() );\r\n\r\n                    if ( ! li.hasClass( 's-l-open' ) )\r\n                    {\r\n                        close( li );\r\n                    }\r\n                    else\r\n                    {\r\n                        open( li );\r\n                    }\r\n                }\r\n            } );\r\n        }\r\n\r\n        if( setting.maxLevels !== false )\r\n        {\r\n            if( isNaN( setting.maxLevels ) ) throw 'JQuery-sortable-lists maxLevels values is not a number';\r\n\r\n            $( this ).find( 'li' ).each( function()\r\n            {\r\n                var insideLevs = getInsideLevels( $(this) );\r\n                var upperLevs = getUpperLevels( $(this) );\r\n                setInsideLevels( $(this), insideLevs );\r\n                setUpperLevels( $(this), upperLevs );\r\n            });\r\n        }\r\n\r\n        // Return this ensures chaining\r\n        return this.on( 'mousedown', function( e )\r\n            {\r\n                var target = $( e.target );\r\n\r\n                if ( state.isDragged !== false || ( setting.ignoreClass && target.closest( '.' + setting.ignoreClass ).length ) ) return; // setting.ignoreClass is checked cause hasClass('') returns true\r\n\r\n                // Solves selection/range highlighting\r\n                e.preventDefault();\r\n\r\n                // El must be li in jQuery object\r\n                var el = target.closest( 'li' ),\r\n                    rEl = $( this );\r\n\r\n                // Check if el is not empty\r\n                if ( el[0] )\r\n                {\r\n                    setting.onDragStart( e, el );\r\n                    startDrag( e, el, rEl );\r\n                }\r\n            }\r\n        );\r\n\r\n        /**\r\n         * @desc Binds events dragging and endDrag, sets some init. values\r\n         * @param e event obj.\r\n         * @param el curr. dragged element\r\n         * @param rEl root element\r\n         */\r\n        function startDrag( e, el, rEl )\r\n        {\r\n            state.isDragged = true;\r\n\r\n            var elMT = parseInt( el.css( 'margin-top' ) ), // parseInt is necesary cause value has px at the end\r\n                elMB = parseInt( el.css( 'margin-bottom' ) ),\r\n                elML = parseInt( el.css( 'margin-left' ) ),\r\n                elMR = parseInt( el.css( 'margin-right' ) ),\r\n                elXY = el.offset(),\r\n                elIH = el.innerHeight();\r\n\r\n            state.rootEl = {\r\n                el: rEl,\r\n                offset: rEl.offset(),\r\n                rootElClass: rEl.attr( 'class' )\r\n            };\r\n\r\n            state.cEl = {\r\n                el: el,\r\n                mT: elMT, mL: elML, mB: elMB, mR: elMR,\r\n                offset: elXY\r\n            };\r\n\r\n            state.cEl.xyOffsetDiff = { X: e.pageX - state.cEl.offset.left, Y: e.pageY - state.cEl.offset.top };\r\n            state.cEl.el.addClass( 's-l-current ' + setting.currElClass );\r\n\r\n            el.before( placeholder );  // Now document has node placeholder\r\n\r\n            var placeholderNode = state.placeholderNode = $( '#s-l-placeholder' );  // jQuery object && document node\r\n\r\n            el.css( {\r\n                'width': el.width(),\r\n                'position': 'absolute',\r\n                'top': elXY.top - elMT,\r\n                'left': elXY.left - elML\r\n            } ).prependTo( base );\r\n\r\n            placeholderNode.css( {\r\n                'display': 'block',\r\n                'height': elIH\r\n            } );\r\n\r\n            hint.css( 'height', elIH );\r\n\r\n            state.doc\r\n                .on( 'mousemove', dragging )\r\n                .on( 'mouseup', endDrag );\r\n        }\r\n\r\n        /**\r\n         * @desc Start dragging\r\n         * @param e event obj.\r\n         */\r\n        function dragging( e )\r\n        {\r\n            if ( state.isDragged )\r\n            {\r\n                var cEl = state.cEl,\r\n                    doc = state.doc,\r\n                    win = state.win;\r\n\r\n                // event triggered by trigger() from setInterval does not have XY properties\r\n                if ( ! e.pageX )\r\n                {\r\n                    setEventPos( e );\r\n                }\r\n\r\n                // Scrolling up\r\n                if ( doc.scrollTop() > state.rootEl.offset.top - 10 && e.clientY < 50 )\r\n                {\r\n                    if ( ! state.upScroll ) // Has to be here after cond. e.clientY < 50 cause else unsets the interval\r\n                    {\r\n                        setScrollUp( e );\r\n                    }\r\n                    else\r\n                    {\r\n                        e.pageY = e.pageY - setting.scroll;\r\n                        $( 'html, body' ).each( function( i )\r\n                        {\r\n                            $( this ).scrollTop( $( this ).scrollTop() - setting.scroll );\r\n                        } );\r\n                        setCursorPos( e );\r\n                    }\r\n                }\r\n                // Scrolling down\r\n                else if ( doc.scrollTop() + win.height() < state.rootEl.offset.top + state.rootEl.el.outerHeight( false ) + 10 && win.height() - e.clientY < 50 )\r\n                {\r\n                    if ( ! state.downScroll )\r\n                    {\r\n                        setScrollDown( e );\r\n                    }\r\n                    else\r\n                    {\r\n                        e.pageY = e.pageY + setting.scroll;\r\n                        $( 'html, body' ).each( function( i )\r\n                        {\r\n                            $( this ).scrollTop( $( this ).scrollTop() + setting.scroll );\r\n                        } );\r\n                        setCursorPos( e );\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    scrollStop( state );\r\n                }\r\n\r\n                // Script needs to know old oEl\r\n                state.oElOld = state.oEl;\r\n\r\n                cEl.el[0].style.visibility = 'hidden';  // This is important for the next row\r\n                state.oEl = oEl = elFromPoint( e.pageX, e.pageY );\r\n                cEl.el[0].style.visibility = 'visible';\r\n\r\n                showHint( e, state );\r\n\r\n                setCElPos( e, state );\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @desc endDrag unbinds events mousemove/mouseup and removes redundant elements\r\n         * @param e\r\n         */\r\n        function endDrag( e )\r\n        {\r\n            var cEl = state.cEl,\r\n                hintNode = $( '#s-l-hint', state.rootEl.el ),\r\n                hintStyle = hint[0].style,\r\n                targetEl = null, // hintNode/placeholderNode\r\n                isHintTarget = false, // if cEl will be placed to the hintNode\r\n                hintWrapperNode = $( '#s-l-hint-wrapper' );\r\n\r\n            if ( hintStyle.display == 'block' && hintNode.length && state.isAllowed )\r\n            {\r\n                targetEl = hintNode;\r\n                isHintTarget = true;\r\n            }\r\n            else\r\n            {\r\n                targetEl = state.placeholderNode;\r\n                isHintTarget = false;\r\n            }\r\n\r\n            offset = targetEl.offset();\r\n\r\n            cEl.el.animate( { left: offset.left - state.cEl.mL, top: offset.top - state.cEl.mT }, 250,\r\n                function()  // complete callback\r\n                {\r\n                    tidyCurrEl( cEl );\r\n\r\n                    targetEl.after( cEl.el[0] );\r\n                    targetEl[0].style.display = 'none';\r\n                    hintStyle.display = 'none';\r\n                    // This has to be document node, not hint as a part of documentFragment.\r\n                    hintNode.remove();\r\n\r\n                    hintWrapperNode\r\n                        .removeAttr( 'id' )\r\n                        .removeClass( setting.hintWrapperClass );\r\n\r\n                    if ( hintWrapperNode.length )\r\n                    {\r\n                        hintWrapperNode.prev( 'div' ).append( opener.clone( true ) );\r\n                    }\r\n\r\n                    // Directly removed placeholder looks bad. It jumps up if the hint is below.\r\n                    if ( isHintTarget )\r\n                    {\r\n                        // !!! Do not use local var cause it seems it creates a closure variables lakes in Chrome !!!\r\n                        state.placeholderNode.slideUp( 150, function()\r\n                        {\r\n                            state.placeholderParentLi = ( ! state.placeholderNode.parent().is( state.rootEl.el ) ) ? state.placeholderNode.parent().closest( 'li' ) : null;\r\n\r\n                            state.placeholderNode.remove();\r\n                            tidyEmptyLists();\r\n\r\n                            setting.onChange( cEl.el );\r\n                            setting.complete( cEl.el ); // Have to be here cause is necessary to remove placeholder before complete call.\r\n                            state.isDragged = false;\r\n\r\n                            if( setting.maxLevels !== false )  // Has to be after placeholder remove.\r\n                            {\r\n                                recountLevels( cEl.el );\r\n                                if( state.placeholderParentLi ) recountLevels( state.placeholderParentLi );\r\n                            }\r\n                        });\r\n                    }\r\n                    else\r\n                    {\r\n                        state.placeholderNode.remove();\r\n                        tidyEmptyLists();\r\n                        setting.complete( cEl.el );\r\n                        state.isDragged = false;\r\n                    }\r\n\r\n                } );\r\n\r\n            scrollStop( state );\r\n\r\n            state.doc\r\n                .unbind( \"mousemove\", dragging )\r\n                .unbind( \"mouseup\", endDrag );\r\n        }\r\n\r\n        //////////////////////////////////////////////////////////////////////////////////////////////////////\r\n        ////////Helpers///////////////////////////////////////////////////////////////////////////////////////\r\n        //////////////////////////////////////////////////////////////////////////////////////////////////////\r\n\r\n        //////// Scroll handlers /////////////////////////////////////////////////////////////////////////////\r\n\r\n        /**\r\n         * @desc Ensures autoscroll up.\r\n         * @param e\r\n         * @return No value\r\n         */\r\n        function setScrollUp( e )\r\n        {\r\n            if ( state.upScroll ) return;\r\n\r\n            state.upScroll = setInterval( function()\r\n            {\r\n                state.doc.trigger( 'mousemove' );\r\n            }, 50 );\r\n        }\r\n\r\n        /**\r\n         * @desc Ensures autoscroll down.\r\n         * @param e\r\n         * @return No value\r\n         */\r\n        function setScrollDown( e )\r\n        {\r\n            if ( state.downScroll ) return;\r\n\r\n            state.downScroll = setInterval( function()\r\n            {\r\n                state.doc.trigger( 'mousemove' );\r\n            }, 50 );\r\n        }\r\n\r\n        /**\r\n         * @desc This properties are used when setScrollUp()/Down() calls trigger('mousemove'), cause trigger() produce event object without pageY/Y and clientX/Y.\r\n         * @param e\r\n         * @return No value\r\n         */\r\n        function setCursorPos( e )\r\n        {\r\n            state.pY = e.pageY;\r\n            state.pX = e.pageX;\r\n            state.cY = e.clientY;\r\n            state.cX = e.clientX;\r\n        }\r\n\r\n        /**\r\n         * @desc Necessary while scrolling, cause trigger('mousemove') does not set cursor XY values in event object\r\n         * @param e\r\n         * @return No value\r\n         */\r\n        function setEventPos( e )\r\n        {\r\n            e.pageY = state.pY;\r\n            e.pageX = state.pX;\r\n            e.clientY = state.cY;\r\n            e.clientX = state.cX;\r\n\r\n        }\r\n\r\n        /**\r\n         * @desc Stops scrolling and sets variables\r\n         * @param state\r\n         * @return No value\r\n         */\r\n        function scrollStop( state )\r\n        {\r\n            clearInterval( state.upScroll );\r\n            clearInterval( state.downScroll );\r\n            // clearInterval have to be before upScroll/downScroll is set to false\r\n            state.upScroll = state.downScroll = false;\r\n        }\r\n\r\n        /////// End of Scroll handlers //////////////////////////////////////////////////////////////\r\n        /////// Current element handlers //////////////////////////////////////////////////////////////\r\n\r\n        /**\r\n         * @desc Sets the position of dragged element\r\n         * @param e event object\r\n         * @param state state object\r\n         * @return No value\r\n         */\r\n        function setCElPos( e, state )\r\n        {\r\n            var cEl = state.cEl;\r\n\r\n            cEl.el.css( {\r\n                'top': e.pageY - cEl.xyOffsetDiff.Y - cEl.mT,\r\n                'left': e.pageX - cEl.xyOffsetDiff.X - cEl.mL\r\n            } );\r\n        }\r\n\r\n        /**\r\n         * @desc Return elementFromPoint() result as jQuery object\r\n         * @param x e.pageX\r\n         * @param y e.pageY\r\n         * @return null|jQuery object\r\n         */\r\n        function elFromPoint( x, y )\r\n        {\r\n            if ( ! document.elementFromPoint ) return null;\r\n\r\n            // FF/IE/CH needs coordinates relative to the window, unlike\r\n            // Opera/Safari which needs absolute coordinates of document in elementFromPoint()\r\n            var isRelEFP = state.isRelEFP;\r\n\r\n            // isRelative === null means it is not checked yet\r\n            if ( isRelEFP === null )\r\n            {\r\n                var s, res;\r\n                if ( (s = state.doc.scrollTop()) > 0 )\r\n                {\r\n                    isRelEFP = ( (res = document.elementFromPoint( 0, s + $( window ).height() - 1 ) ) == null\r\n                    || res.tagName.toUpperCase() == 'HTML');  // IE8 returns html\r\n                }\r\n                if ( (s = state.doc.scrollLeft()) > 0 )\r\n                {\r\n                    isRelEFP = ( (res = document.elementFromPoint( s + $( window ).width() - 1, 0 ) ) == null\r\n                    || res.tagName.toUpperCase() == 'HTML');  // IE8 returns html\r\n                }\r\n            }\r\n\r\n            if ( isRelEFP )\r\n            {\r\n                x -= state.doc.scrollLeft();\r\n                y -= state.doc.scrollTop();\r\n            }\r\n\r\n            // Returns jQuery object\r\n            var el = $( document.elementFromPoint( x, y ) );\r\n\r\n            if ( ! state.rootEl.el.find( el ).length ) // el is outside the rootEl\r\n            {\r\n                return null;\r\n            }\r\n            else if ( el.is( '#s-l-placeholder' ) || el.is( '#s-l-hint' ) ) // el is #placeholder/#hint\r\n            {\r\n                return null;\r\n            }\r\n            else if ( ! el.is( 'li' ) ) // el is ul or div or something else in li elem.\r\n            {\r\n                el = el.closest( 'li' );\r\n                return el[0] ? el : null;\r\n            }\r\n            else if ( el.is( 'li' ) ) // el is most wanted li\r\n            {\r\n                return el;\r\n            }\r\n        }\r\n\r\n        //////// End of current element handlers //////////////////////////////////////////////////////\r\n        //////// Show hint handlers //////////////////////////////////////////////////////\r\n\r\n        /**\r\n         * @desc Shows or hides or does not show hint element\r\n         * @param e event\r\n         * @param state\r\n         * @return No value\r\n         */\r\n        function showHint( e, state )\r\n        {\r\n            var oEl = state.oEl;\r\n\r\n            // If oEl is null or if this is the first call in dragging\r\n            if ( ! oEl || ! state.oElOld )  return;\r\n\r\n            var oElH = oEl.outerHeight( false ),\r\n                relY = e.pageY - oEl.offset().top;\r\n\r\n            if ( setting.insertZonePlus )\r\n            {\r\n                if ( 14 > relY )  // Inserting on top\r\n                {\r\n                    showOnTopPlus( e, oEl, 7 > relY );  // Last bool param express if hint insert outside/inside\r\n                }\r\n                else if ( oElH - 14 < relY )  // Inserting on bottom\r\n                {\r\n                    showOnBottomPlus( e, oEl, oElH - 7 < relY );\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if ( 5 > relY )  // Inserting on top\r\n                {\r\n                    showOnTop( e, oEl );\r\n                }\r\n                else if ( oElH - 5 < relY )  // Inserting on bottom\r\n                {\r\n                    showOnBottom( e, oEl );\r\n                }\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @desc Called from showHint method. Displays or hides hint element\r\n         * @param e event\r\n         * @param oEl oElement\r\n         * @return No value\r\n         */\r\n        function showOnTop( e, oEl )\r\n        {\r\n            if ( $( '#s-l-hint-wrapper', state.rootEl.el ).length )\r\n            {\r\n                hint.unwrap();  // If hint is wrapped by ul/ol #s-l-hint-wrapper\r\n            }\r\n\r\n            // Hint outside the oEl\r\n            if ( e.pageX - oEl.offset().left < setting.insertZone )\r\n            {\r\n                // Ensure display:none if hint will be next to the placeholder\r\n                if ( (oEl.prev( '#s-l-placeholder' ).length) || (setting.maxLevels !== false && ! checkMaxLevels( false )) )\r\n                {\r\n                    hint.css( 'display', 'none' );\r\n                    return;\r\n                }\r\n                oEl.before( hint );\r\n            }\r\n            // Hint inside the oEl\r\n            else\r\n            {\r\n                var children = oEl.children(),\r\n                    list = oEl.children( setting.listSelector ).first();\r\n\r\n                if ( (list.children().first().is( '#s-l-placeholder' )) || ( setting.maxLevels !== false && ! checkMaxLevels( true )) )\r\n                {\r\n                    hint.css( 'display', 'none' );\r\n                    return;\r\n                }\r\n\r\n                // Find out if is necessary to wrap hint by hintWrapper\r\n                if ( ! list.length )\r\n                {\r\n                    children.first().after( hint );\r\n                    hint.wrap( hintWrapper );\r\n                }\r\n                else\r\n                {\r\n                    list.prepend( hint );\r\n                }\r\n\r\n                if ( state.oEl )\r\n                {\r\n                    open( oEl ); // TODO:animation??? .children('ul,ol').css('display', 'block');\r\n                }\r\n\r\n            }\r\n\r\n            hint.css( 'display', 'block' );\r\n            // Ensures posible formating of elements. Second call is in the endDrag method.\r\n            state.isAllowed = setting.isAllowed( state.cEl.el, hint, hint.parents( 'li' ).first() );\r\n\r\n        }\r\n\r\n        /**\r\n         * @desc Called from showHint method. Displays or hides hint element\r\n         * @param e event\r\n         * @param oEl oElement\r\n         * @param outside bool\r\n         * @return No value\r\n         */\r\n        function showOnTopPlus( e, oEl, outside )\r\n        {\r\n            if ( $( '#s-l-hint-wrapper', state.rootEl.el ).length )\r\n            {\r\n                hint.unwrap();  // If hint is wrapped by ul/ol #s-l-hint-wrapper\r\n            }\r\n\r\n            // Hint inside the oEl\r\n            if ( ! outside && e.pageX - oEl.offset().left > setting.insertZone )\r\n            {\r\n                var children = oEl.children(),\r\n                    list = oEl.children( setting.listSelector ).first();\r\n\r\n                if ( (list.children().first().is( '#s-l-placeholder' )) || (setting.maxLevels !== false && ! checkMaxLevels( true )) )\r\n                {\r\n                    hint.css( 'display', 'none' );\r\n                    return;\r\n                }\r\n\r\n                // Find out if is necessary to wrap hint by hintWrapper\r\n                if ( ! list.length )\r\n                {\r\n                    children.first().after( hint );\r\n                    hint.wrap( hintWrapper );\r\n                }\r\n                else\r\n                {\r\n                    list.prepend( hint );\r\n                }\r\n\r\n                if ( state.oEl )\r\n                {\r\n                    open( oEl ); // TODO:animation??? .children('ul,ol').css('display', 'block');\r\n                }\r\n            }\r\n            // Hint outside the oEl\r\n            else\r\n            {\r\n                // Ensure display:none if hint will be next to the placeholder\r\n                if ( (oEl.prev( '#s-l-placeholder' ).length) || (setting.maxLevels !== false && ! checkMaxLevels( false )) )\r\n                {\r\n                    hint.css( 'display', 'none' );\r\n                    return;\r\n                }\r\n                oEl.before( hint );\r\n\r\n            }\r\n\r\n            hint.css( 'display', 'block' );\r\n            // Ensures posible formating of elements. Second call is in the endDrag method.\r\n            state.isAllowed = setting.isAllowed( state.cEl.el, hint, hint.parents( 'li' ).first() );\r\n\r\n        }\r\n\r\n        /**\r\n         * @desc Called from showHint function. Displays or hides hint element.\r\n         * @param e event\r\n         * @param oEl oElement\r\n         * @return No value\r\n         */\r\n        function showOnBottom( e, oEl )\r\n        {\r\n            if ( $( '#s-l-hint-wrapper', state.rootEl.el ).length )\r\n            {\r\n                hint.unwrap();  // If hint is wrapped by ul/ol s-l-hint-wrapper\r\n            }\r\n\r\n            // Hint outside the oEl\r\n            if ( e.pageX - oEl.offset().left < setting.insertZone )\r\n            {\r\n                // Ensure display:none if hint will be next to the placeholder\r\n                if ( (oEl.next( '#s-l-placeholder' ).length) || (setting.maxLevels !== false && ! checkMaxLevels( false )) )\r\n                {\r\n                    hint.css( 'display', 'none' );\r\n                    return;\r\n                }\r\n                oEl.after( hint );\r\n            }\r\n            // Hint inside the oEl\r\n            else\r\n            {\r\n                var children = oEl.children(),\r\n                    list = oEl.children( setting.listSelector ).last();  // ul/ol || empty jQuery obj\r\n\r\n                if ( (list.children().last().is( '#s-l-placeholder' )) || (setting.maxLevels !== false && ! checkMaxLevels( true )) )\r\n                {\r\n                    hint.css( 'display', 'none' );\r\n                    return;\r\n                }\r\n\r\n                // Find out if is necessary to wrap hint by hintWrapper\r\n                if ( list.length )\r\n                {\r\n                    children.last().append( hint );\r\n                }\r\n                else\r\n                {\r\n                    oEl.append( hint );\r\n                    hint.wrap( hintWrapper );\r\n                }\r\n\r\n                if ( state.oEl )\r\n                {\r\n                    open( oEl ); // TODO: animation???\r\n                }\r\n\r\n            }\r\n\r\n            hint.css( 'display', 'block' );\r\n            // Ensures posible formating of elements. Second call is in the endDrag method.\r\n            state.isAllowed = setting.isAllowed( state.cEl.el, hint, hint.parents( 'li' ).first() );\r\n\r\n        }\r\n\r\n        /**\r\n         * @desc Called from showHint function. Displays or hides hint element.\r\n         * @param e event\r\n         * @param oEl oElement\r\n         * @param outside bool\r\n         * @return No value\r\n         */\r\n        function showOnBottomPlus( e, oEl, outside )\r\n        {\r\n            if ( $( '#s-l-hint-wrapper', state.rootEl.el ).length )\r\n            {\r\n                hint.unwrap();  // If hint is wrapped by ul/ol s-l-hint-wrapper\r\n            }\r\n\r\n            // Hint inside the oEl\r\n            if ( ! outside && e.pageX - oEl.offset().left > setting.insertZone )\r\n            {\r\n                var children = oEl.children(),\r\n                    list = oEl.children( setting.listSelector ).last();  // ul/ol || empty jQuery obj\r\n\r\n                if ( (list.children().last().is( '#s-l-placeholder' )) || (setting.maxLevels !== false && ! checkMaxLevels( true )) )\r\n                {\r\n                    hint.css( 'display', 'none' );\r\n                    return;\r\n                }\r\n\r\n                // Find out if is necessary to wrap hint by hintWrapper\r\n                if ( list.length )\r\n                {\r\n                    children.last().append( hint );\r\n                }\r\n                else\r\n                {\r\n                    oEl.append( hint );\r\n                    hint.wrap( hintWrapper );\r\n                }\r\n\r\n                if ( state.oEl )\r\n                {\r\n                    open( oEl ); // TODO: animation???\r\n                }\r\n\r\n            }\r\n            // Hint outside the oEl\r\n            else\r\n            {\r\n                // Ensure display:none if hint will be next to the placeholder\r\n                if ( (oEl.next( '#s-l-placeholder' ).length) || (setting.maxLevels !== false && ! checkMaxLevels( false )) )\r\n                {\r\n                    hint.css( 'display', 'none' );\r\n                    return;\r\n                }\r\n                oEl.after( hint );\r\n\r\n            }\r\n\r\n            hint.css( 'display', 'block' );\r\n            // Ensures posible formating of elements. Second call is in the endDrag method.\r\n            state.isAllowed = setting.isAllowed( state.cEl.el, hint, hint.parents( 'li' ).first() );\r\n\r\n        }\r\n\r\n        //////// End of show hint handlers ////////////////////////////////////////////////////\r\n        //////// Open/close handlers //////////////////////////////////////////////////////////\r\n\r\n        /**\r\n         * @desc Handles opening nested lists\r\n         * @param li\r\n         */\r\n        function open( li )\r\n        {\r\n            li.removeClass( 's-l-closed' ).addClass( 's-l-open' );\r\n            li.children( setting.listSelector ).css( 'display', 'block' );\r\n\r\n            var opener = li.children( 'div' ).children( '.s-l-opener' ).first();\r\n\r\n            if ( setting.opener.as == 'html' )\r\n            {\r\n                opener.html( setting.opener.close );\r\n            }\r\n            else if ( setting.opener.as == 'class' )\r\n            {\r\n                opener.addClass( setting.opener.close ).removeClass( setting.opener.open );\r\n            }\r\n        }\r\n\r\n        /**\r\n         * @desc Handles opening nested lists\r\n         * @param li\r\n         */\r\n        function close( li )\r\n        {\r\n            li.removeClass( 's-l-open' ).addClass( 's-l-closed' );\r\n            li.children( setting.listSelector ).css( 'display', 'none' );\r\n\r\n            var opener = li.children( 'div' ).children( '.s-l-opener' ).first();\r\n\r\n            if ( setting.opener.as == 'html' )\r\n            {\r\n                opener.html( setting.opener.open );\r\n            }\r\n            else if ( setting.opener.as == 'class' )\r\n            {\r\n                opener.addClass( setting.opener.open ).removeClass( setting.opener.close );\r\n            }\r\n\r\n        }\r\n\r\n        /////// Enf of open/close handlers //////////////////////////////////////////////\r\n        /////// Levels handlers /////////////////////////////////////////////////////////\r\n\r\n        function getInsideLevels( li )\r\n        {\r\n            var levs = 0;\r\n\r\n            var list = li.children( setting.listSelector );\r\n\r\n            if( list.length )\r\n            {\r\n                levs++;\r\n                var maxNestedLevs = 0;\r\n                var currLiLevs = 0;\r\n                list.find( 'li' ).each( function( i )\r\n                {\r\n                    currLiLevs = getInsideLevels($(this));\r\n                    if( maxNestedLevs < currLiLevs ) maxNestedLevs = currLiLevs;\r\n                });\r\n\r\n                if( maxNestedLevs ) levs = levs + maxNestedLevs;\r\n            }\r\n\r\n            return levs;\r\n        }\r\n\r\n        function setInsideLevels( li, levs )\r\n        {\r\n            li.data('inside-levels', levs);\r\n        }\r\n\r\n        function getUpperLevels( li )\r\n        {\r\n            var levs = 0;\r\n            var rootEl = state.rootEl.el;\r\n            var parentList = li.closest( setting.listSelector );\r\n\r\n            while( ! parentList.is( rootEl ) )\r\n            {\r\n                levs++;\r\n                parentList = parentList.parent().closest( setting.listSelector );\r\n            }\r\n\r\n            return levs;\r\n        }\r\n\r\n        function setUpperLevels( li, levs )\r\n        {\r\n            li.data('upper-levels', levs);\r\n        }\r\n\r\n        function checkMaxLevels( inside )\r\n        {\r\n            var insideLevs = state.cEl.el.data( 'inside-levels' );\r\n            var upperLevs = state.oEl.data( 'upper-levels' );\r\n\r\n            return setting.maxLevels > upperLevs + insideLevs + (inside ? 1 : 0);\r\n        }\r\n\r\n        function recountLevels( li )\r\n        {\r\n            var rootEl = state.rootEl.el;\r\n            var parentList = li.parent( setting.listSelector );\r\n\r\n            setInsideLevels( li, getInsideLevels( li ) );\r\n            setUpperLevels( li, getUpperLevels( li ) );\r\n\r\n            var i = 0;\r\n            li.find( 'li' ).each( function()\r\n            {\r\n                var li = $(this);\r\n                setInsideLevels( li, getInsideLevels( li ) );\r\n                setUpperLevels( li, getUpperLevels( li ) );\r\n            });\r\n\r\n            while( ! parentList.is( rootEl ) && i < 50 )\r\n            {\r\n                var li = parentList.parent( 'li' );\r\n                setInsideLevels( li, getInsideLevels( li ) ); // No need to set upper levels\r\n                parentList = li.parent( setting.listSelector );\r\n                i++;\r\n            }\r\n        }\r\n\r\n        /////// End of levels handlers //////////////////////////////////////////////////\r\n        /////// Tidy handlers ///////////////////////////////////////////////////////////\r\n\r\n        /**\r\n         * @desc Places the currEl to the target place\r\n         * @param cEl\r\n         */\r\n        function tidyCurrEl( cEl )\r\n        {\r\n            var cElStyle = cEl.el[0].style;\r\n\r\n            cEl.el.removeClass( setting.currElClass + ' s-l-current' );\r\n            cElStyle.top = '0';\r\n            cElStyle.left = '0';\r\n            cElStyle.position = 'relative';\r\n            cElStyle.width = 'auto';\r\n\r\n        }\r\n\r\n        /**\r\n         * @desc Removes empty lists and redundant openers\r\n         */\r\n        function tidyEmptyLists()\r\n        {\r\n            // Remove every empty ul/ol from root and also with .s-l-opener\r\n            // hintWrapper can not be removed before the hint\r\n            $( setting.listSelector, state.rootEl.el ).each( function( i )\r\n                {\r\n                    if ( ! $( this ).children().length )\r\n                    {\r\n                        $( this ).prev( 'div' ).children( '.s-l-opener' ).first().remove();\r\n                        $( this ).remove();\r\n                    }\r\n                }\r\n            );\r\n\r\n        }\r\n\r\n    };\r\n\r\n\r\n    //// toArray /////////////////////////////////////////////////////////////////////////////////////\r\n\r\n    /**\r\n     * @desc jQuery plugin\r\n     * @returns this to unsure chaining\r\n     */\r\n    $.fn.sortableListsToArray = function( arr, parentId )\r\n    {\r\n        arr = arr || [];\r\n        var order = 0;\r\n\r\n        this.children( 'li' ).each( function()\r\n        {\r\n            var li = $( this ),\r\n                listItem = {},\r\n                id = li.attr( 'id' );\r\n\r\n            if ( ! id )\r\n            {\r\n                console.log( li ); // Have to be here! Read next exception message.\r\n                throw 'Previous item in console.log has no id. It is necessary to create the array.';\r\n            }\r\n\r\n            listItem.id = id;\r\n            listItem.parentId = parentId;\r\n            listItem.value = li.data( 'value' );\r\n            listItem.order = order;\r\n            arr.push( listItem );\r\n            li.children( 'ul,ol' ).sortableListsToArray( arr, id );\r\n            order ++;\r\n        } );\r\n\r\n        return arr;\r\n\r\n    };\r\n\r\n    /**\r\n     * @desc jQuery plugin\r\n     * @returns this to unsure chaining\r\n     */\r\n    $.fn.sortableListsToHierarchy = function()\r\n    {\r\n        var arr = [],\r\n            order = 0;\r\n\r\n        $( this ).children( 'li' ).each( function()\r\n        {\r\n            var li = $( this ),\r\n                listItem = {},\r\n                id = li.attr( 'id' );\r\n\r\n            if ( ! id )\r\n            {\r\n                console.log( li ); // Have to be here! Read next exception message.\r\n                throw 'Previous item in console.log has no id. It is necessary to create the array.';\r\n            }\r\n            listItem.id = id;\r\n            listItem.value = li.data( 'value' );\r\n            listItem.order = order;\r\n            arr.push( listItem );\r\n            listItem.children = li.children( 'ul,ol' ).sortableListsToHierarchy();\r\n            order ++;\r\n        } );\r\n\r\n        return arr;\r\n\r\n    };\r\n\r\n    /**\r\n     * @desc jQuery plugin\r\n     * @returns string\r\n     */\r\n    $.fn.sortableListsToString = function( arr, parentId )\r\n    {\r\n        arr = arr || [];\r\n        parentId = parentId || 'no-parent'; // string \"0\" is evaluate to true and is valid\r\n\r\n        $( this ).children( 'li' ).each( function()\r\n        {\r\n            var li = $( this ),\r\n                id = li.attr( 'id' ),\r\n                matches = id ? id.match( /(.+)[-=_](.+)/ ) : null; // string \"0\" is evaluate to true but is not valid\r\n\r\n            if ( ! matches )\r\n            {\r\n                console.log( li );  // Have to be here. Read next exception message.\r\n                throw 'Previous item in console.log has no id or id is not in required format xx_yy, xx-yy or xx=yy. It is necessary to create valid string.';\r\n            }\r\n\r\n            arr.push( matches[1] + '[' + matches[2] + ']=' + parentId );\r\n            $( this ).children( 'ul,ol' ).sortableListsToString( arr, matches[2] );\r\n\r\n        } );\r\n\r\n        return arr.join( '&' );\r\n\r\n    };\r\n\r\n}( jQuery ));\n\n//# sourceURL=webpack://sails-adminpanel/./assets/src/navigation/js/jquery-sortable-lists.min.js?");

/***/ })

}]);